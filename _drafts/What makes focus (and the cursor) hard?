What makes focus (and the cursor) hard?

There can only be one (or zero?) on the whole page.

Most other aspects of the appearance of the page are managed by properties (size, alignment, color, etc.). Focus is managed by an effect. To get focus, you must also "take" focus from elsewhere.

If you decide to rerender the part of the DOM that has focus, it's easy to lose focus (or the cursor position)

setSelectionRange only works on documents that already have focus.

What to do about this situation? One idea is to keep track of activeElement, and avoid replacing it or its parents if the new model has a corresponding element.

Another idea is to try to restore focus and selection whenever we replace the active element.

How do we communicate to the system where focus should be? If we model it with a property on elements, then it's very easy to get into an inconsistent state by having more than one element claim to be focused.

JS doesn't really have a concept of a resource that can be in only one "place".

An alternative way to model things is to have a "cursor" at the top level of the model that stores a path through the DOM to its location.

One thing that's frustrating about this is that it isn't "composable". E.g. if a calculator model has a "cursor", then we can't have multiple calculators on the page because then we would have multiple cursors.

update: Action (Cursor, Model) -> (Cursor, Model)
view: (Cursor, Model) -> View

Model selection as a pair of cursors. When there is no selection, this pair is degenerate. When a selection begins, one member of the pair remains fixed at the start position, and the other member moves according to the various commands.

Components are responsible for changing their display based on whether the cursor is "inside" them.

If a "click" (or other input event) happens in one child of a component, the component needs to somehow know how to remove the cursor from one of its children, and move it to another child.

It doesn't actually make sense to say that a cursor points to a place in the model abstractly. In some cases, one "model" has multiple different representations in the view. For example, think about a "settings" menu that controls font sizes. Cursors ultimately have to point to locations on the screen, so it's more like they point to a location in a view than in a model.

Elm's whole model of "onClick" seems slightly suspect if you need to manage something like focus. Need to be able to respond to a click *anywhere* on the screen.

At what level does the browser model selection? How much does it depend on source order vs. visual layout?

